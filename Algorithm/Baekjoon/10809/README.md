# 백준 10809번 - 알파벳 찾기

## 문제 링크
- [백준 10809번 - 알파벳 찾기] (https://www.acmicpc.net/problem/10809)

## 문제 요약
- 알파베 소문자로만 이루어진 단어 S가 주어짐. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램. (단어의 길이는 100을 넘지 않는다)
## 풀이 아이디어
- 모든 알파벳 소문자가 들어가 있는 리스트와, 모든 값이 -1로 초기화되어있는 길이가 같은 리스트를 만든다. 그리고 문자열과 알파벳 소문자가 들어있는 리스트를 비교해, 만약 해당 인덱스에 값이 있으면 모든 값이 -1로 초기화되어있는 리스트의 동일 인덱스의 값을 수정한다. 
만약 똑같은 알파벳이 주어졌을 경우, 최초로 등장하는 위치만 기억해야 하므로 -1로 초기화되어있는 리스트의 값을 수정할 때 "리스트의 값이 -1일때만 값을 수정한다" 라는 조건을 넣어 최초 등장 위치만 기억하도록 했다. 
## 최종 코드
    # 알파벳 소문자로만 이루어진 단어 S가 주어진다. 
    s = str(input())

    # 알파벳 소문자 리스트를 만들 때 아스키코드로 사용할 값
    alpha_i = 97

    # 모든 알파벳 소문자가 들어간 리스트 생성
    alphabat_list = []
    for i in range(26) :
        alphabat_list.append(chr(alpha_i))
        alpha_i += 1

    # 결과값을 출력할 리스트 생성
    result = []
    for i in range(26) :
        result.append(-1)

    # 알파벳이 단어에 포함되어 있지 않다면 -1을 출력. 

    alpha_i = 97 # 반복문 돌며 증가했던 값 다시 초기화

    # "처음으로 등장하는 위치" -> 같은 알파벳이 두 개 이상 주어지면,
    # 처음 위치만 기억하도록 해야 함. 중복 제거하는 부분을 언제?
    for i in range(len(alphabat_list)) :
        for sub_i in range(len(s)) :
            if alphabat_list[i] == s[sub_i] :
                if result[i] == -1 :
                    result[i] = sub_i

    # 각각의 알파벳에 대해서, 각 알파벳이 처음 등장하는 위치를 공백으로 구분해서 출력.
    # 리스트 형태로 출력하면 안되니까..
    for i in range(len(result)) :
        print(result[i], end=" ")



